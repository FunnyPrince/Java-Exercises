package com.day10;

/**
 * @author FunnyPrince_
 * @date 2021/4/2 - 18:49
 *
 * 方法的重写(override)
 * 1.重写：子类继承父类之后，可以对父类中同名同参数的方法，进行覆盖操作
 * 2.应用：重写以后，当创建子类对象后，通过子类对象调用子父类中的同名同参数时，执行的是子类重写的方法
 * 3.重写的规定：
 *      方法的声明：权限修饰符 返回值类型 方法名(形参列表)throws 异常的类型{}
 *      子类中称：重写方法    父类中：被重写方法
 *      1.子类重写的方法的方法名和形参列表与父类中被重写的方法名和形参列表相同
 *      2.子类重写的方法的权限修饰符>=父类被重写方法的权限修饰符(>=)
 *      >特殊情况：子类不能重写父类中private的方法
 *      3.返回值类型
 *      >父类被重写的方法的返回值类型void，子类也必须是void
 *      >父类：A类(Object)   子类：A类/A类的子类(String)
 *      >父类：基本数据类型(double)    子类：相同的基本数据类型(double)
 *      4.子类重写的方法抛出的异常类型<=被重写的方法抛出的异常类型
 *******************************************************
 *    子类和父类中的同名同参数的方法要么都static(不是重写)，要么都非static(考虑重写)
 *    static方法是随着类的加载而加载的，不能被覆盖/重写
 *
 *
 * super关键字的使用：调用属性/方法
 *    1.super可以用来调用：属性、方法、构造器
 *    2.super的使用：
 *       >在子类的方法/构造器中，使用"super.属性/方法",显式调用父类中声明的属性/方法，经常省略
 *       >特殊情况：1.当子类和父类中定义了同名的属性时，想在子类中调用父类中声明的属性，必须显式地使用"super.属性/方法"，表明调用的是父类中声明的属性/方法
 *super调用构造器
 *  1.可以在子类的构造器中显式地使用"super(形参列表)"方式，调用父类中声明的指定的构造器
 *  2."super(形参列表)"的使用，必须声明在子类构造器的首行
 *  3."this(形参列表)"/"super(形参列表)",只能二选一
 *  4.在构造器首行，没有显式声明"this(形参列表)"/"super(形参列表)"，默认调用父类的空参构造器super();
 *  5.在类的多个构造器中，至少有一个类的构造器中使用了"super(形参列表)",调用父类中的构造器
 *
 * 面试题：区分方法的重载与重写
 *
 *
 */
public class PersonTest {
    public static void main(String[] args) {
        Student s = new Student();
        s.eat();
        s.walk(10);

        s.study();
        s.show();



        //super的使用
        s.show();
        System.out.println("测试子类构造器中是否默认调用父类空参构造器");
        Student s2 = new Student();
    }
}
